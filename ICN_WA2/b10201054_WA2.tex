\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{interval}
\usepackage{amssymb}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{ICN Written Assignment 2}
\author{Student ID: b10201054}

\begin{document}
\maketitle

\section*{Problem 1}

\begin{enumerate}
    \item [(a)] 
        The fowarding table is:
        \begin{table}[!ht]
            \centering
            \begin{tabular}{|l|l|}
            \hline
                Destination Address Range & Link Interface \\ \hline
                11100000 00 & 0 \\ \hline
                11100000 01000000 & 1 \\ \hline
                11100000  & 2 \\ \hline
                11100001 0 & 2 \\ \hline
                otherwise & 3 \\ \hline
            \end{tabular}
            \caption{Forwarding Table}
        \end{table}
        
    \item[(b)]
        
        11001000 10010001 01010001 01010101 doesn't match any prefix in destination address range, so the packet would be sent to Link 3.

        11100001 01000000 11000011 00111100 matches matches the prefix of Link 1 longer than Link 2, so the packet would be sent to Link 1.

        11100001 10000000 00010001 01110111 doesn't matches any prefix in destination address range, so the packet would be sent to Link 3.
        
\end{enumerate}

\section*{Problem 2}    

\begin{enumerate}
    \item [(a)] 
        214.97.254/23 to 32-bit binary is 11010110 01100001 11111110 ********.\\
        The first 23 bits is the subnet part, so we can only use the last 9 digits.\\
        Subnet A: 214.97.255/24
        Subnet B: 214.97.254.0/25 - 214.97.254.0/29 \\
        Subnet C: 214.97.254.128/25 \\
        Subnet D: 214.97.254.0/31 \\
        Subnet E: 214.97.254.2/31 \\
        Subnet F: 214.97.254.4/30
    \item[(b)]
        Forwarding table:
        \begin{table}[!ht]
            \centering
            \begin{tabular}{|l|l|}
            \hline
                Longest Prefix Match & Outgoing Interface \\ \hline
                11010110 01100001 11111111 & A \\ \hline
                11010110 01100001 11111110 0000000 & D \\ \hline
                11010110 01100001 11111110 000001  & F \\ \hline
            \end{tabular}
            \caption{Router 1 Forwarding Table}
        \end{table}

        \begin{table}[!ht]
            \centering
            \begin{tabular}{|l|l|}
            \hline
                Longest Prefix Match & Outgoing Interface \\ \hline
                11010110 01100001 11111110 1 & C \\ \hline
                11010110 01100001 11111110 0000001 & E \\ \hline
                11010110 01100001 11111110 000001  & F \\ \hline
            \end{tabular}
            \caption{Router 2 Forwarding Table}
        \end{table}

        \begin{table}[!ht]
            \centering
            \begin{tabular}{|l|l|}
            \hline
                Longest Prefix Match & Outgoing Interface \\ \hline
                11010110 01100001 11111110 0 & B \\ \hline
                11010110 01100001 11111110 0000000 & D \\ \hline
                11010110 01100001 11111110 0000001  & E \\ \hline
            \end{tabular}
            \caption{Router 3 Forwarding Table}
        \end{table}

\end{enumerate}

\section*{Problem 3}    

\begin{enumerate}
    \item [(a)] 
        The header of each packet has 20 bytes, MTU = 700 bytes means for each packet we have header 20 + content 680 bytes.
        Then the 2400 bytes datagram = header 20 + content 2380.
        The link will cut the datagram in 680, 680, 680, 340 four fragments.

    \item[(b)]
        Identification: 1 1 1 1
        fragflag: 1 1 1 0
        fragment offset: 0 85 170 255
        length: 700 700 700 360

\end{enumerate}

\section*{Problem 4}

\begin{enumerate}
    \item [(a)] 
        We can record all packets sent from the NAT, since the hosts send the packet with sequencial numbers and a random initial ID number, we can group the consecutive ID number to a cluster.
        Then we can find the initial number of the cluster. The number of cluster means the number of distinct initial number, so we will know the number of host through the distinct initial ID number. 
    \item[(b)]
        The technique used in (a) is based on the sequencial number. Because of the sequencial assigned number, we can find the initial ID number in technique (a).
        If the ID number is randomly assigned, we cannot find the assigned rule of the ID number. Hence, we cannot know which number is the initial ID number of the host.
    
\end{enumerate}

\section*{Problem 5}

\section*{Problem 6}
Dijkstra's algorithm table:
\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|l|}
    \hline
        step & N' & D(t), p(t) & D(u), p(u) & D(v), p(v) & D(w), p(w) & D(y), p(y) & D(z),p(z) \\ \hline
        0 & x & $\infty$ & $\infty$ & 3,x & 6,x & 6,x & 6,x \\ \hline
        1 & xv & 7,v & 6,v & - & 6,x & 6,x & 6,x \\ \hline
        2 & xvw & 7,v & 6,v & - & - & 6,x & 6,x \\ \hline
        3 & xvwy & 7,v & 6,v & - & - & - & 6,x \\ \hline
        4 & xvwyz & 7,v & 6,v & - & - & - & - \\ \hline
        5 & xvwyzu & 7,v & - & - & - & - & - \\ \hline
        6 & xvwyzut & - & - & - & - & - & - \\ \hline
    \end{tabular}
    \caption{Dijkstra's algorithm table}
\end{table}
\section*{Problem 7}

\begin{enumerate}
    \item [(a)] 
        
    \item[(b)]
        
    \item[(c)]
        
    \item[(d)]
        

\end{enumerate}

\section*{Problem 8}

\begin{enumerate}
    \item [(a)] 
        The time it costs from the source host to the first packet switch is
        \[
            d_{1} = \frac{8\cdot 10^{6}}{2\cdot 10^{6}} = 4 \text{ sec}
        \]
        Since each switch uses store-and-forward packet switching, the message start transmitting after the last bit of the message arrived.
        Every link costs $d_{1}$ sec to transmit the message.
        Hence, the total time cost is $3d_{1} = 12$ sec.
    \item[(b)]
        The time cost from the source host to the first packet switch is 
        \[
            d_{1} = \frac{10^{4}}{2\cdot 10^{6}} = 5\cdot 10^{-3} \text{ sec}
        \]
        The second packet is being sent from the source host to the first switch while the first packet is being sent from the first switch to the second switch.
        The second packet has the size 10000 bits. The transmit rate is $2\cdot 10^{6}$ bps.
        Hence the time cost is
        \[
            d = d_{1} + \frac{10^{4}}{2\cdot 10^{6}} = 10^{-3} \text{ sec}
        \]
        After $10^{-3}$ sec, the second packet is fully received at the first switch.
    \item[(c)]
        Each packet from a switch to the next switch cost $d = \frac{10^{4}}{2\cdot 10^{6}} = 5\cdot 10^{-3}$ sec.
        By (b). we know that we can send packet from the source host to the first switch and from the first switch to the second switch simultaneously.
        \\
        Hence, when $t = 2d$, the first packet arrived the second switch, and the second packet arrived the first switch.
        \\
        When $t = 3d$, the first packet arrived the destination, the second packet arrived the second switch, and the third packet arrived the first switch.
        Then we can observe that the first packet cost $3d$ and the second packet will soon arrive destination after $d$ sec.
        \\
        The total time cost is 
        \[
            d_{total} = 3d + d\cdot(800-1) = 802\cdot 5\cdot 10^{-3} = 4.01 \text{ sec}
        \]
        To compare the result of (a)., (c). has reserved about 8 sec in transmitting. The reason is because in (a)., we need to wait until the last bit of the data arrived, the first bit can start being transmitted to the next switch.
        But in (c)., the first packet didn't need to wait the second packet, which reserved the delay in waiting all data transmitted completely.
    \item[(d)]
        We can avoid congestion when transmitting. If we don't use message segmentation, the switch needs 4 sec to send a data in this example, if there is another data which is sent to this switch in 4 sec. The data would stay at input queue.
        If there are too much data transmitted from other switches, data loss would happen. If we use message segmentation, we can divided the data into several packets, and send them to different switch to transmit, so that each packet would not cost too long in transmitting.
        The congestion might not happen.

\end{enumerate}

\end{document}
